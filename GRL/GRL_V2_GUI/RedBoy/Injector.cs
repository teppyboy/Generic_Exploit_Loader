using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

namespace RedBoy
{
    // Token: 0x02000003 RID: 3
    internal class Injector
    {
        // Token: 0x0200000C RID: 12
        public enum DllInjectionResult
        {
            // Token: 0x04000125 RID: 293
            DllNotFound,
            // Token: 0x04000126 RID: 294
            GameProcessNotFound,
            // Token: 0x04000127 RID: 295
            InjectionFailed,
            // Token: 0x04000128 RID: 296
            Success
        }

        // Token: 0x0200000D RID: 13
        public sealed class DllInjector
        {
            // Token: 0x0600013A RID: 314
            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern IntPtr OpenProcess(uint dwDesiredAccess, int bInheritHandle, uint dwProcessId);

            // Token: 0x0600013B RID: 315
            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern int CloseHandle(IntPtr hObject);

            // Token: 0x0600013C RID: 316
            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

            // Token: 0x0600013D RID: 317
            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern IntPtr GetModuleHandle(string lpModuleName);

            // Token: 0x0600013E RID: 318
            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, IntPtr dwSize, uint flAllocationType, uint flProtect);

            // Token: 0x0600013F RID: 319
            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern int WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] buffer, uint size, int lpNumberOfBytesWritten);

            // Token: 0x06000140 RID: 320
            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttribute, IntPtr dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

            // Token: 0x17000017 RID: 23
            // (get) Token: 0x06000141 RID: 321 RVA: 0x0001B47C File Offset: 0x0001967C
            public static Injector.DllInjector GetInstance
            {
                get
                {
                    bool flag = Injector.DllInjector._instance == null;
                    if (flag)
                    {
                        Injector.DllInjector._instance = new Injector.DllInjector();
                    }
                    return Injector.DllInjector._instance;
                }
            }

            // Token: 0x06000142 RID: 322 RVA: 0x0001B4AB File Offset: 0x000196AB
            private DllInjector()
            {
            }

            // Token: 0x06000143 RID: 323 RVA: 0x0001B4B8 File Offset: 0x000196B8
            public Injector.DllInjectionResult Inject(string sProcName, string sDllPath)
            {
                bool flag = !File.Exists(sDllPath);
                Injector.DllInjectionResult result;
                if (flag)
                {
                    result = Injector.DllInjectionResult.DllNotFound;
                }
                else
                {
                    uint num = 0u;
                    Process[] processes = Process.GetProcesses();
                    for (int i = 0; i < processes.Length; i++)
                    {
                        bool flag2 = processes[i].ProcessName == sProcName;
                        if (flag2)
                        {
                            num = (uint)processes[i].Id;
                            break;
                        }
                    }
                    bool flag3 = num == 0u;
                    if (flag3)
                    {
                        result = Injector.DllInjectionResult.GameProcessNotFound;
                    }
                    else
                    {
                        bool flag4 = !this.bInject(num, sDllPath);
                        if (flag4)
                        {
                            result = Injector.DllInjectionResult.InjectionFailed;
                        }
                        else
                        {
                            result = Injector.DllInjectionResult.Success;
                        }
                    }
                }
                return result;
            }

            // Token: 0x06000144 RID: 324 RVA: 0x0001B548 File Offset: 0x00019748
            private bool bInject(uint pToBeInjected, string sDllPath)
            {
                IntPtr intPtr = Injector.DllInjector.OpenProcess(1082u, 1, pToBeInjected);
                bool flag = intPtr == Injector.DllInjector.INTPTR_ZERO;
                bool result;
                if (flag)
                {
                    result = false;
                }
                else
                {
                    IntPtr procAddress = Injector.DllInjector.GetProcAddress(Injector.DllInjector.GetModuleHandle("kernel32.dll"), "LoadLibraryA");
                    bool flag2 = procAddress == Injector.DllInjector.INTPTR_ZERO;
                    if (flag2)
                    {
                        result = false;
                    }
                    else
                    {
                        IntPtr intPtr2 = Injector.DllInjector.VirtualAllocEx(intPtr, (IntPtr)null, (IntPtr)sDllPath.Length, 12288u, 64u);
                        bool flag3 = intPtr2 == Injector.DllInjector.INTPTR_ZERO;
                        if (flag3)
                        {
                            result = false;
                        }
                        else
                        {
                            byte[] bytes = Encoding.ASCII.GetBytes(sDllPath);
                            bool flag4 = Injector.DllInjector.WriteProcessMemory(intPtr, intPtr2, bytes, (uint)bytes.Length, 0) == 0;
                            if (flag4)
                            {
                                result = false;
                            }
                            else
                            {
                                bool flag5 = Injector.DllInjector.CreateRemoteThread(intPtr, (IntPtr)null, Injector.DllInjector.INTPTR_ZERO, procAddress, intPtr2, 0u, (IntPtr)null) == Injector.DllInjector.INTPTR_ZERO;
                                if (flag5)
                                {
                                    result = false;
                                }
                                else
                                {
                                    Injector.DllInjector.CloseHandle(intPtr);
                                    result = true;
                                }
                            }
                        }
                    }
                }
                return result;
            }

            // Token: 0x04000129 RID: 297
            private static readonly IntPtr INTPTR_ZERO = (IntPtr)0;

            // Token: 0x0400012A RID: 298
            private static Injector.DllInjector _instance;
        }
    }
}
